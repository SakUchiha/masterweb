class APIService{constructor(){this.cache=new Map,this.pendingRequests=new Map}async request(t,e={},s=!0){const a=`${CONFIG.API_BASE_URL}${t}`,r=`${e.method||"GET"}-${a}`;if(s&&this.cache.has(r)){const t=this.cache.get(r);if(Date.now()-t.timestamp<CONFIG.CACHE_DURATION)return t.data;this.cache.delete(r)}if(this.pendingRequests.has(r))return this.pendingRequests.get(r);const i=new AbortController,n=setTimeout(()=>i.abort(),CONFIG.API_TIMEOUT),c=fetch(a,{...e,signal:i.signal,headers:{"Content-Type":"application/json",...e.headers}}).then(async t=>{clearTimeout(n);const a=(t.headers.get("content-type")||"").toLowerCase();if(!t.ok){let e={};throw e=a.includes("application/json")?await t.json().catch(()=>({})):{error:await t.text().catch(()=>"")||`${t.status} ${t.statusText}`},new Error(e.error||`HTTP ${t.status}: ${t.statusText}`)}let i;if(a.includes("application/json"))i=await t.json().catch(t=>({}));else{const e=await t.text().catch(()=>"");try{i=e?JSON.parse(e):{}}catch(t){i={__raw:e}}}return!s||e.method&&"GET"!==e.method||this.cache.set(r,{data:i,timestamp:Date.now()}),i}).catch(t=>{if(clearTimeout(n),"AbortError"===t.name)throw new Error("Request timeout");throw t}).finally(()=>{this.pendingRequests.delete(r)});return this.pendingRequests.set(r,c),c}get(t,e=!0){return this.request(t,{method:"GET"},e)}post(t,e){return this.request(t,{method:"POST",body:JSON.stringify(e)},!1)}put(t,e){return this.request(t,{method:"PUT",body:JSON.stringify(e)},!1)}delete(t){return this.request(t,{method:"DELETE"},!1)}clearCache(){this.cache.clear()}async checkAvailability(){try{return await this.get("/api/lessons",!1),!0}catch(t){return!1}}}const apiService=new APIService;window.apiService=apiService;