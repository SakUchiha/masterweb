class APIService{constructor(){this.cache=new Map,this.pendingRequests=new Map}async request(e,t={},s=!0){const a=`${CONFIG.API_BASE_URL}${e}`,r=`${t.method||"GET"}-${a}`;if(s&&this.cache.has(r)){const e=this.cache.get(r);if(Date.now()-e.timestamp<CONFIG.CACHE_DURATION)return e.data;this.cache.delete(r)}if(this.pendingRequests.has(r))return this.pendingRequests.get(r);const i=new AbortController,n=setTimeout(()=>i.abort(),CONFIG.API_TIMEOUT),c=fetch(a,{...t,signal:i.signal,headers:{"Content-Type":"application/json",...t.headers}}).then(async e=>{clearTimeout(n);const a=(e.headers.get("content-type")||"").toLowerCase();if(!e.ok){let t={};if(a.includes("application/json"))t=await e.json().catch(()=>({}));else{t={error:await e.text().catch(()=>"")||`${e.status} ${e.statusText}`}}throw new Error(t.error||`HTTP ${e.status}: ${e.statusText}`)}let i;if(a.includes("application/json"))i=await e.json().catch(e=>({}));else{const t=await e.text().catch(()=>"");try{i=t?JSON.parse(t):{}}catch(e){i={__raw:t}}}return!s||t.method&&"GET"!==t.method||this.cache.set(r,{data:i,timestamp:Date.now()}),i}).catch(e=>{if(clearTimeout(n),"AbortError"===e.name)throw new Error("Request timeout");throw e}).finally(()=>{this.pendingRequests.delete(r)});return this.pendingRequests.set(r,c),c}get(e,t=!0){return this.request(e,{method:"GET"},t)}post(e,t){return this.request(e,{method:"POST",body:JSON.stringify(t)},!1)}put(e,t){return this.request(e,{method:"PUT",body:JSON.stringify(t)},!1)}delete(e){return this.request(e,{method:"DELETE"},!1)}clearCache(){this.cache.clear()}async checkAvailability(){try{return await this.get("/api/lessons",!1),!0}catch(e){return!1}}}const apiService=new APIService;window.apiService=apiService;